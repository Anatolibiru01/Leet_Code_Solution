{"name":"remove-duplicates-from-sorted-list","url":"https://leetcode.com/problems/remove-duplicates-from-sorted-list/description/","tests":[{"id":1770195886230,"input":"2\n3\n1 1 2\n5\n1 1 2 3 3\n","output":"[1,2]\n[1,2,3]"}],"interactive":false,"memoryLimit":256,"timeLimit":2000,"group":"LeetCode","parsedCode":"from typing import *\nimport collections\nfrom collections import deque, defaultdict, Counter, OrderedDict\nimport random\nimport heapq\nimport bisect\nimport itertools\nfrom functools import lru_cache, reduce\nfrom math import inf, gcd, lcm, sqrt, ceil, floor, log, log2, log10\nimport re\nimport string\n\n# Global input buffer for single word reading\nclass InputBuffer:\n    def __init__(self):\n        self.buffer = []\n        self.index = 0\n    \n    def next_word(self):\n        while self.index >= len(self.buffer):\n            try:\n                line = input().strip()\n                if line:\n                    self.buffer = line.split()\n                    self.index = 0\n                else:\n                    continue\n            except EOFError:\n                return None\n        \n        word = self.buffer[self.index]\n        self.index += 1\n        return word\n    \n    def next_line(self):\n        self.buffer = []\n        self.index = 0\n        try:\n            return input().strip()\n        except EOFError:\n            return None\n\n_input_buffer = InputBuffer()\n\n# Definition for singly-linked list\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n# Definition for binary tree node\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass IO:\n    class Input:\n        @staticmethod\n        def read_bool() -> bool:\n            word = _input_buffer.next_word()\n            return word.lower() in ['true'] if word else False\n        \n        @staticmethod\n        def read_int() -> int:\n            word = _input_buffer.next_word()\n            return int(word) if word else 0\n        \n        @staticmethod\n        def read_float() -> float:\n            word = _input_buffer.next_word()\n            return float(word) if word else 0.0\n        \n        @staticmethod\n        def read_string() -> str:\n            return _input_buffer.next_line()\n        \n        @staticmethod\n        def read_char() -> str:\n            word = _input_buffer.next_word()\n            return word[0] if word else ''\n        \n        @staticmethod\n        def consume_newline() -> None:\n            _input_buffer.next_line()\n        \n        # Array functions\n        @staticmethod\n        def read_int_array() -> List[int]:\n            n = IO.Input.read_int()  \n            if n == 0:\n                IO.Input.consume_newline()\n            return [IO.Input.read_int() for _ in range(n)] \n        \n        @staticmethod\n        def read_float_array() -> List[float]:\n            n = IO.Input.read_int()  \n            if n == 0:\n                IO.Input.consume_newline()\n            return [IO.Input.read_float() for _ in range(n)]  \n        \n        @staticmethod\n        def read_string_array() -> List[str]:\n            n = IO.Input.read_int() \n            if n == 0:\n                IO.Input.consume_newline()\n            return [IO.Input.read_string() for _ in range(n)]  \n        \n        @staticmethod\n        def read_char_array() -> List[str]:\n            n = IO.Input.read_int() \n            if n == 0:\n                IO.Input.consume_newline()\n            return [IO.Input.read_char() for _ in range(n)]  \n        \n        # 2D Array functions\n        @staticmethod\n        def read_int_2d_array() -> List[List[int]]:\n            m = IO.Input.read_int()  \n            if m == 0:\n                IO.Input.consume_newline()\n            result = []\n            for _ in range(m):\n                row = IO.Input.read_int_array()\n                result.append(row)\n            return result\n        \n        @staticmethod\n        def read_char_2d_array() -> List[List[str]]:\n            m = IO.Input.read_int() \n            if m == 0:\n                IO.Input.consume_newline()\n            result = []\n            for _ in range(m):\n                row = IO.Input.read_char_array()\n                result.append(row)\n            return result\n        \n        # Linked List\n        @staticmethod\n        def read_list_node() -> Optional[ListNode]:\n            n = IO.Input.read_int()\n            if n == 0:\n                return None\n            \n            values = [IO.Input.read_int() for _ in range(n)]\n            if not values:\n                return None\n                \n            head = ListNode(values[0])\n            current = head\n            for i in range(1, len(values)):\n                current.next = ListNode(values[i])\n                current = current.next\n            return head\n        \n        # Binary Tree (level-order traversal format)\n        @staticmethod\n        def read_tree_node() -> Optional[TreeNode]:\n            n = IO.Input.read_int()\n            if n == 0:\n                return None\n                \n            values = []\n            for _ in range(n):\n                word = _input_buffer.next_word()\n                if word and word.lower() == 'null':\n                    values.append(None)\n                else:\n                    values.append(int(word) if word else 0)\n            \n            if not values or values[0] is None:\n                return None\n            \n            root = TreeNode(values[0])\n            queue = deque([root])\n            i = 1\n            \n            while queue and i < len(values):\n                node = queue.popleft()\n                \n                if i < len(values):\n                    if values[i] is not None:\n                        node.left = TreeNode(values[i])\n                        queue.append(node.left)\n                    i += 1\n                \n                if i < len(values):\n                    if values[i] is not None:\n                        node.right = TreeNode(values[i])\n                        queue.append(node.right)\n                    i += 1\n            \n            return root\n        \n    class Output:\n        @staticmethod\n        def write_bool(x: bool) -> None:\n            print(\"true\" if x else \"false\", end=\"\")\n        \n        @staticmethod\n        def write_int(x: int) -> None:\n            print(x, end=\"\")\n        \n        @staticmethod\n        def write_float(x: float) -> None:\n            print(x, end=\"\")\n        \n        @staticmethod\n        def write_string(x: str) -> None:\n            print(f'\"{x}\"', end=\"\")\n        \n        @staticmethod\n        def write_char(x: str) -> None:\n            print(f'\"{x}\"', end=\"\")\n        \n        # Array functions\n        @staticmethod\n        def write_int_array(arr: List[int]) -> None:\n            print(\"[\", end=\"\")\n            for i, val in enumerate(arr):\n                print(val, end=\"\")\n                if i < len(arr) - 1:\n                    print(\",\", end=\"\")\n            print(\"]\", end=\"\")\n        \n        @staticmethod\n        def write_float_array(arr: List[float]) -> None:\n            print(\"[\", end=\"\")\n            for i, val in enumerate(arr):\n                print(val, end=\"\")\n                if i < len(arr) - 1:\n                    print(\",\", end=\"\")\n            print(\"]\", end=\"\")\n        \n        @staticmethod\n        def write_string_array(arr: List[str]) -> None:\n            print(\"[\", end=\"\")\n            for i, val in enumerate(arr):\n                print(f'\"{val}\"', end=\"\")\n                if i < len(arr) - 1:\n                    print(\",\", end=\"\")\n            print(\"]\", end=\"\")\n        \n        @staticmethod\n        def write_char_array(arr: List[str]) -> None:\n            print(\"[\", end=\"\")\n            for i, val in enumerate(arr):\n                print(f'\"{val}\"', end=\"\")\n                if i < len(arr) - 1:\n                    print(\",\", end=\"\")\n            print(\"]\", end=\"\")\n        \n        # 2D Array functions\n        @staticmethod\n        def write_int_2d_array(arr: List[List[int]]) -> None:\n            print(\"[\", end=\"\")\n            for i, row in enumerate(arr):\n                IO.Output.write_int_array(row)\n                if i < len(arr) - 1:\n                    print(\",\", end=\"\")\n            print(\"]\", end=\"\")\n        \n        @staticmethod\n        def write_char_2d_array(arr: List[List[str]]) -> None:\n            print(\"[\", end=\"\")\n            for i, row in enumerate(arr):\n                IO.Output.write_char_array(row)\n                if i < len(arr) - 1:\n                    print(\",\", end=\"\")\n            print(\"]\", end=\"\")\n        \n        # Linked List\n        @staticmethod\n        def write_list_node(head: Optional[ListNode]) -> None:\n            print(\"[\", end=\"\")\n            first = True\n            current = head\n            while current:\n                if not first:\n                    print(\",\", end=\"\")\n                first = False\n                print(current.val, end=\"\")\n                current = current.next\n            print(\"]\", end=\"\")\n        \n        # Binary Tree (level-order output)\n        @staticmethod\n        def write_tree_node(root: Optional[TreeNode]) -> None:\n            if not root:\n                print(\"[]\", end=\"\")\n                return\n            \n            print(\"[\", end=\"\")\n            queue = deque([root])\n            first = True\n            \n            while queue:\n                level_size = len(queue)\n                has_next_level = False\n                \n                for _ in range(level_size):\n                    node = queue.popleft()\n                    \n                    if not first:\n                        print(\", \", end=\"\")\n                    first = False\n                    \n                    if node:\n                        print(node.val, end=\"\")\n                        queue.append(node.left)\n                        queue.append(node.right)\n                        if node.left or node.right:\n                            has_next_level = True\n                    else:\n                        print(\"null\", end=\"\")\n                \n                if not has_next_level:\n                    break\n            \n            print(\"]\", end=\"\")\n        \n        # List of TreeNodes\n        @staticmethod\n        def write_tree_node_array(arr: List[Optional[TreeNode]]) -> None:\n            print(\"[\", end=\"\")\n            for i, tree in enumerate(arr):\n                IO.Output.write_tree_node(tree)\n                if i < len(arr) - 1:\n                    print(\",\", end=\"\")\n            print(\"]\", end=\"\")\n    \n    # Convenience wrapper functions\n    @staticmethod\n    def output(x) -> None:\n        if x is None:\n            print(\"null\", end=\"\")\n        elif isinstance(x, bool):\n            IO.Output.write_bool(x)\n        elif isinstance(x, int):\n            IO.Output.write_int(x)\n        elif isinstance(x, float):\n            IO.Output.write_float(x)\n        elif isinstance(x, str) and len(x) == 1:\n            IO.Output.write_char(x)\n        elif isinstance(x, str):\n            IO.Output.write_string(x)\n        elif isinstance(x, list):\n            if x and isinstance(x[0], list):\n                # 2D array\n                if x[0] and isinstance(x[0][0], int):\n                    IO.Output.write_int_2d_array(x)\n                elif x[0] and isinstance(x[0][0], str):\n                    IO.Output.write_char_2d_array(x)\n                else:\n                    print(x, end=\"\")\n            elif x and isinstance(x[0], int):\n                IO.Output.write_int_array(x)\n            elif x and isinstance(x[0], float):\n                IO.Output.write_float_array(x)\n            elif x and isinstance(x[0], str):\n                if all(len(s) == 1 for s in x):\n                    IO.Output.write_char_array(x)\n                else:\n                    IO.Output.write_string_array(x)\n            elif x and isinstance(x[0], TreeNode):\n                IO.Output.write_tree_node_array(x)\n            else:\n                print(x, end=\"\")\n        elif isinstance(x, ListNode):\n            IO.Output.write_list_node(x)\n        elif isinstance(x, TreeNode):\n            IO.Output.write_tree_node(x)\n        else:\n            print(x, end=\"\")\n\n \n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \n\ndef main():\n    t = IO.Input.read_int()\n    for _ in range(t):\n        head = IO.Input.read_list_node()\n        solution = Solution()\n        result = solution.deleteDuplicates(head)\n        IO.output(result)\n        print()\n\n\nif __name__ == \"__main__\":\n    main()","language":"python","srcPath":"c:\\Users\\hp\\Desktop\\leet_code_soltions\\remove_duplicates_from_sorted_list.py"}