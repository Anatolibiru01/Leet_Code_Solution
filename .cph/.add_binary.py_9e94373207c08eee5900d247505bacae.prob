{"name":"add-binary","url":"https://leetcode.com/problems/add-binary/","tests":[{"id":1770195381364,"input":"2\n11\n1\n1010\n1011\n","output":"\"100\"\n\"10101\""}],"interactive":false,"memoryLimit":256,"timeLimit":2000,"group":"LeetCode","parsedCode":"#include<bits/stdc++.h>\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nnamespace IO {\n    namespace Input {\n        // Basic types\n        void read(bool& x) { cin >> x; }\n        void read(char& x) { cin >> x; }\n        void read(int& x) { cin >> x; }\n        void read(unsigned int& x) { cin >> x; }\n        void read(long int& x) { cin >> x; }\n        void read(unsigned long& x) { cin >> x; }\n        void read(long long int& x) { cin >> x; }\n        void read(unsigned long long& x) { cin >> x; }\n        void read(float& x) { cin >> x; }\n        void read(double& x) { cin >> x; }\n        void read(long double& x) { cin >> x; }\n        \n        // String with whitespace handling\n        void read(string& x) { \n            cin >> ws; \n            getline(cin, x); \n        }\n        \n        // Linked list\n        void read(ListNode*& head) {\n            int n; \n            cin >> n;\n            if (n == 0) { \n                head = nullptr; \n                return; \n            }\n            vector<int> values(n);\n            for (int i = 0; i < n; i++) { \n                cin >> values[i]; \n            }\n            head = new ListNode(values[0]);\n            ListNode* current = head;\n            for (int i = 1; i < n; i++) {\n                current->next = new ListNode(values[i]);\n                current = current->next;\n            }\n        }\n        \n        // Binary tree (level-order traversal format)\n        void read(TreeNode*& root) {\n            int n; \n            cin >> n;\n            if (n == 0) { \n                root = nullptr; \n                return;\n            }\n            vector<string> values(n);\n            for (int i = 0; i < n; i++) {\n                cin >> values[i]; \n            }\n            if (values[0] == \"null\") {\n                root = nullptr; \n                return;\n            }\n            root = new TreeNode(stoi(values[0]));\n            queue<TreeNode*> q;\n            q.push(root);\n            int i = 1;\n            while (!q.empty() && i < n) {\n                TreeNode* node = q.front();\n                q.pop();\n                if (i < n) {\n                    if (values[i] != \"null\") {\n                        node->left = new TreeNode(stoi(values[i]));\n                        q.push(node->left);\n                    }\n                    i++;\n                }\n                if (i < n) {\n                    if (values[i] != \"null\") {\n                        node->right = new TreeNode(stoi(values[i]));\n                        q.push(node->right);\n                    }\n                    i++;\n                }\n            }\n        }\n\n        template <typename T> void read(vector<T>& x);\n        \n        // Vector\n        template <typename T>\n        void read(vector<T>& x) {\n            int n;\n            cin >> n;\n            x.resize(n);\n            for (int i = 0; i < n; i++) {\n                read(x[i]);\n            }\n        }\n    } // namespace Input\n    \n    namespace Output {\n        // Basic types\n        void write(bool x) { cout << (x ? \"True\" : \"False\"); }\n        void write(char x) { cout << \"\\\"\" << x << \"\\\"\"; }\n        void write(int x) { cout << x; }\n        void write(unsigned int x) { cout << x; }\n        void write(long int x) { cout << x; }\n        void write(unsigned long x) { cout << x; }\n        void write(long long int x) { cout << x; }\n        void write(unsigned long long x) { cout << x; }\n        void write(float x) { cout << x; }\n        void write(double x) { cout << x; }\n        void write(long double x) { cout << x; }\n        void write(string x) { cout << \"\\\"\" << x << \"\\\"\"; }\n        void write(const char* x) { cout << \"\\\"\" << x << \"\\\"\"; }\n        \n        // Linked list\n        void write(ListNode* head) {\n            cout << \"[\";\n            bool first = true;\n            while (head) {\n                if (!first) cout << \",\";\n                first = false;\n                cout << head->val;\n                head = head->next;\n            }\n            cout << \"]\";\n        }\n        \n        // Binary tree (level-order output)\n        void write(TreeNode* root) {\n            if (!root) {\n                cout << \"[]\";\n                return;\n            }\n            cout << \"[\";\n            queue<TreeNode*> q;\n            q.push(root);\n            bool first = true;\n            while (!q.empty()) {\n                int levelSize = q.size();\n                bool hasNextLevel = false;\n                for (int i = 0; i < levelSize; i++) {\n                    TreeNode* node = q.front();\n                    q.pop();\n                    if (!first) cout << \",\";\n                    first = false;\n                    if (node) {\n                        cout << node->val;\n                        q.push(node->left);\n                        q.push(node->right);\n                        if (node->left || node->right) hasNextLevel = true;\n                    } else {\n                        cout << \"null\";\n                    }\n                }\n                if (!hasNextLevel) break;\n            }\n            cout << \"]\";\n        }\n        \n        template <typename T> void write(const vector<T>& x);\n        \n        // Vector\n        template <typename T>\n        void write(const vector<T>& x) {\n            cout << \"[\";\n            int n = x.size();\n            for (int i = 0; i < n; i++) {\n                write(x[i]);\n                if (i < n - 1) cout << \",\";\n            }\n            cout << \"]\";\n        }\n    } // namespace Output\n    \n    template <typename T>\n    void input(T& x) {\n        Input::read(x);\n    }\n    \n    template <typename T>\n    void output(T x) {\n        Output::write(x);\n    }\n} \n\nusing namespace IO;\n\n \n\nclass Solution {\npublic:\n    string addBinary(string a, string b) {\n        k = int(a,2) + int()\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int t;\n    input(t);\n    while (t--) {\n        string a;\n        input(a);\n        string b;\n        input(b);\n        Solution obj;\n        output(obj.addBinary(a,b));\n        cout << endl;\n    }\n    \n    return 0;\n}","language":"cpp","srcPath":"c:\\Users\\hp\\Desktop\\leet_code_soltions\\add_binary.py"}